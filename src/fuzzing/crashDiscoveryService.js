const vscode = require("vscode");
const fs = require("fs").promises;
const path = require("path");
const dockerOperations = require("../core/dockerOperations");

/**
 * CrashDiscoveryService - Discovers and parses fuzzing crash files
 *
 * This service uses the find-crashes.sh script to discover crash files
 * generated by fuzzing operations and returns structured crash data.
 *
 * Directory structure expected:
 * .codeforge/fuzzing/{FUZZER}-output/crash-{HASH}
 */
class CrashDiscoveryService {
  constructor(resourceManager = null) {
    this.fs = fs;
    this.path = path;
    this.resourceManager = resourceManager;
  }

  /**
   * Executes the find-crashes.sh script to discover crash files
   * @param {string} workspacePath - Path to the workspace root
   * @param {string} imageName - Docker image name for script execution
   * @returns {Promise<Array>} Array of {fuzzerName, crashHash} objects
   */
  async executeFindCrashesScript(workspacePath, imageName) {
    return new Promise((resolve, reject) => {
      const options = {
        removeAfterRun: true,
        mountWorkspace: true,
        dockerCommand: "docker",
        containerType: "crash_discovery",
      };

      // Execute the find-crashes.sh script
      const findCommand = ".codeforge/scripts/find-crashes.sh";

      const findProcess = dockerOperations.runDockerCommandWithOutput(
        workspacePath,
        imageName,
        findCommand,
        "/bin/bash",
        { ...options, resourceManager: this.resourceManager },
      );

      let stdout = "";
      let stderr = "";

      findProcess.stdout.on("data", (data) => {
        stdout += data.toString();
      });

      findProcess.stderr.on("data", (data) => {
        stderr += data.toString();
      });

      findProcess.on("close", (code) => {
        if (code !== 0) {
          // Handle case where no crashes are found (not an error)
          if (
            stderr.includes("No crashes found") ||
            stdout.trim().length === 0
          ) {
            console.log("No crashes found in project");
            resolve([]);
            return;
          }

          reject(
            new Error(
              `Find crashes script failed with exit code ${code}: ${stderr}`,
            ),
          );
          return;
        }

        try {
          // Parse script output: "fuzzer_name/crash_hash" format
          const crashList = this.parseFindCrashesScriptOutput(stdout);
          resolve(crashList);
        } catch (parseError) {
          reject(
            new Error(
              `Failed to parse find crashes script output: ${parseError.message}`,
            ),
          );
        }
      });

      findProcess.on("error", (error) => {
        reject(
          new Error(`Failed to execute find crashes script: ${error.message}`),
        );
      });
    });
  }

  /**
   * Parses the output from find-crashes.sh script
   * @param {string} stdout - Script output
   * @returns {Array} Array of {fuzzerName, crashHash} objects
   */
  parseFindCrashesScriptOutput(stdout) {
    const crashList = [];
    const lines = stdout
      .trim()
      .split("\n")
      .filter((line) => line.trim());

    for (const line of lines) {
      const trimmedLine = line.trim();
      if (trimmedLine && trimmedLine.includes("/")) {
        const [fuzzerName, crashHash] = trimmedLine.split("/", 2);
        if (fuzzerName && crashHash) {
          crashList.push({
            fuzzerName: fuzzerName.trim(),
            crashHash: crashHash.trim(),
          });
        }
      }
    }

    return crashList;
  }

  /**
   * Scans for crashes in the workspace fuzzing directories
   * @param {string} workspacePath - Path to the workspace root
   * @param {string} imageName - Optional Docker image name for script execution
   * @returns {Promise<FuzzerCrashData[]>} Array of fuzzer crash data
   */
  async discoverCrashes(workspacePath, imageName = null) {
    const fuzzingDir = this.path.join(workspacePath, ".codeforge", "fuzzing");

    try {
      await this.fs.access(fuzzingDir);
    } catch (error) {
      // No fuzzing directory exists - this is normal for new projects
      return [];
    }

    try {
      // Generate image name if not provided
      if (!imageName) {
        imageName = dockerOperations.generateContainerName(workspacePath);
      }

      // Execute find-crashes.sh script to get crash files
      const crashList = await this.executeFindCrashesScript(
        workspacePath,
        imageName,
      );

      // Group crashes by fuzzer and build detailed crash info
      const crashDataMap = new Map();

      for (const crashItem of crashList) {
        const { fuzzerName, crashHash } = crashItem;

        // Build crash file path
        const outputDir = this.path.join(fuzzingDir, `${fuzzerName}-output`);

        // Check if crash file exists in corpus subdirectory first (LibFuzzer default location)
        let crashFilePath = this.path.join(
          outputDir,
          "corpus",
          `crash-${crashHash}`,
        );
        try {
          await this.fs.access(crashFilePath);
        } catch {
          // Fall back to output directory root for backward compatibility
          crashFilePath = this.path.join(outputDir, `crash-${crashHash}`);
        }

        // Get crash info with file stats
        let crashInfo;
        try {
          crashInfo = await this.buildCrashInfo(
            crashFilePath,
            crashHash,
            fuzzerName,
          );
        } catch (error) {
          console.warn(
            `Failed to get crash info for ${crashFilePath}: ${error.message}`,
          );
          continue;
        }

        // Add to fuzzer's crash list
        if (!crashDataMap.has(fuzzerName)) {
          crashDataMap.set(fuzzerName, {
            fuzzerName,
            crashes: [],
            outputDir,
            lastScan: new Date().toISOString(),
          });
        }

        crashDataMap.get(fuzzerName).crashes.push(crashInfo);
      }

      // Convert map to array and sort crashes within each fuzzer
      const crashData = Array.from(crashDataMap.values()).map((fuzzerData) => ({
        ...fuzzerData,
        crashes: fuzzerData.crashes.sort((a, b) =>
          b.createdAt.localeCompare(a.createdAt),
        ),
      }));

      return crashData;
    } catch (error) {
      // Handle permission errors and other file system issues
      if (this.isPermissionError(error)) {
        throw new Error(
          `Permission denied while scanning for crashes: ${error.message}`,
        );
      }
      throw new Error(`Failed to scan for crashes: ${error.message}`);
    }
  }

  /**
   * Builds crash info object from crash file path and hash
   * @param {string} crashFilePath - Path to crash file
   * @param {string} crashHash - Full crash hash
   * @param {string} fuzzerName - Name of the fuzzer
   * @returns {Promise<CrashInfo>} Crash information object
   */
  async buildCrashInfo(crashFilePath, crashHash, fuzzerName) {
    const fileName = this.path.basename(crashFilePath);
    const id = crashHash.substring(0, 9); // First 9 characters as specified

    try {
      const stats = await this.fs.stat(crashFilePath);

      return {
        id,
        fullHash: crashHash,
        fileName,
        filePath: crashFilePath,
        fileSize: stats.size,
        createdAt: stats.birthtime.toISOString(),
        fuzzerName,
      };
    } catch (error) {
      throw new Error(
        `Failed to get file stats for ${crashFilePath}: ${error.message}`,
      );
    }
  }

  /**
   * Checks if an error is a permission-related error on any platform
   * @param {Error} error - The error to check
   * @returns {boolean} True if it's a permission error
   */
  isPermissionError(error) {
    // Unix permission error codes
    if (error.code === "EACCES" || error.code === "EPERM") {
      return true;
    }

    // Windows permission error codes
    if (error.code === "EBUSY" || error.code === "ENOTEMPTY") {
      return true;
    }

    // Check error message for Windows permission patterns
    const message = error.message.toLowerCase();
    if (
      message.includes("permission denied") ||
      message.includes("access denied") ||
      message.includes("operation not permitted")
    ) {
      return true;
    }

    return false;
  }
}

module.exports = { CrashDiscoveryService };
