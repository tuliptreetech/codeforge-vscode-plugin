const vscode = require("vscode");
const fs = require("fs").promises;
const path = require("path");

/**
 * CrashDiscoveryService - Discovers and parses fuzzing crash files
 *
 * This service scans the .codeforge/fuzzing directory structure for crash files
 * generated by fuzzing operations and returns structured crash data.
 *
 * Directory structure expected:
 * .codeforge/fuzzing/codeforge-{FUZZER}-fuzz-output/crash-{HASH}
 */
class CrashDiscoveryService {
  constructor() {
    this.fs = fs;
    this.path = path;
  }

  /**
   * Scans for crashes in the workspace fuzzing directories
   * @param {string} workspacePath - Path to the workspace root
   * @returns {Promise<FuzzerCrashData[]>} Array of fuzzer crash data
   */
  async discoverCrashes(workspacePath) {
    const fuzzingDir = this.path.join(workspacePath, ".codeforge", "fuzzing");

    try {
      await this.fs.access(fuzzingDir);
    } catch (error) {
      // No fuzzing directory exists - this is normal for new projects
      return [];
    }

    try {
      const fuzzerDirs = await this.findFuzzerDirectories(fuzzingDir);
      const crashData = [];

      for (const fuzzerDir of fuzzerDirs) {
        const fuzzerName = this.extractFuzzerName(fuzzerDir);
        const crashes = await this.findCrashFiles(fuzzerDir);

        if (crashes.length > 0) {
          crashData.push({
            fuzzerName,
            crashes,
            outputDir: fuzzerDir,
            lastScan: new Date().toISOString(),
          });
        }
      }

      return crashData;
    } catch (error) {
      // Handle permission errors and other file system issues
      throw new Error(`Failed to scan for crashes: ${error.message}`);
    }
  }

  /**
   * Finds all fuzzer output directories matching the expected pattern
   * @param {string} fuzzingDir - Path to the fuzzing directory
   * @returns {Promise<string[]>} Array of fuzzer directory paths
   */
  async findFuzzerDirectories(fuzzingDir) {
    try {
      const entries = await this.fs.readdir(fuzzingDir, {
        withFileTypes: true,
      });
      return entries
        .filter(
          (entry) =>
            entry.isDirectory() &&
            entry.name.match(/^codeforge-.+-fuzz-output$/),
        )
        .map((entry) => this.path.join(fuzzingDir, entry.name));
    } catch (error) {
      if (error.code === "ENOENT") {
        return [];
      }
      throw error;
    }
  }

  /**
   * Extracts fuzzer name from directory name
   * @param {string} fuzzerDir - Path to fuzzer directory
   * @returns {string} Fuzzer name
   */
  extractFuzzerName(fuzzerDir) {
    const dirName = this.path.basename(fuzzerDir);
    const match = dirName.match(/^codeforge-(.+)-fuzz-output$/);
    return match ? match[1] : dirName;
  }

  /**
   * Finds all crash files in a fuzzer directory
   * @param {string} fuzzerDir - Path to fuzzer directory
   * @returns {Promise<CrashInfo[]>} Array of crash information
   */
  async findCrashFiles(fuzzerDir) {
    try {
      await this.fs.access(fuzzerDir);
    } catch (error) {
      // No fuzzer directory - this is normal if no crashes occurred
      return [];
    }

    try {
      const entries = await this.fs.readdir(fuzzerDir, { withFileTypes: true });
      const crashFiles = entries
        .filter((entry) => entry.isFile() && entry.name.startsWith("crash-"))
        .map((entry) => this.path.join(fuzzerDir, entry.name));

      const crashes = [];
      for (const crashFile of crashFiles) {
        try {
          const crashInfo = await this.parseCrashFile(crashFile);
          crashes.push(crashInfo);
        } catch (error) {
          // Log but don't fail for individual malformed crash files
          console.warn(
            `Failed to parse crash file ${crashFile}: ${error.message}`,
          );
        }
      }

      // Sort by creation time, newest first
      return crashes.sort((a, b) => b.createdAt.localeCompare(a.createdAt));
    } catch (error) {
      if (error.code === "ENOENT") {
        return [];
      }
      throw error;
    }
  }

  /**
   * Parses a crash file and extracts metadata
   * @param {string} crashFilePath - Path to crash file
   * @returns {Promise<CrashInfo>} Crash information object
   */
  async parseCrashFile(crashFilePath) {
    const fileName = this.path.basename(crashFilePath);
    const fullHash = fileName.replace("crash-", "");
    const id = fullHash.substring(0, 9); // First 9 characters as specified

    try {
      const stats = await this.fs.stat(crashFilePath);

      return {
        id,
        fullHash,
        fileName,
        filePath: crashFilePath,
        fileSize: stats.size,
        createdAt: stats.birthtime.toISOString(),
        fuzzerName: this.extractFuzzerNameFromPath(crashFilePath),
      };
    } catch (error) {
      throw new Error(
        `Failed to get file stats for ${crashFilePath}: ${error.message}`,
      );
    }
  }

  /**
   * Extracts fuzzer name from crash file path
   * @param {string} crashFilePath - Path to crash file
   * @returns {string} Fuzzer name
   */
  extractFuzzerNameFromPath(crashFilePath) {
    const pathParts = crashFilePath.split(this.path.sep);
    const fuzzerDirIndex = pathParts.findIndex((part) =>
      part.match(/^codeforge-.+-fuzz-output$/),
    );
    if (fuzzerDirIndex >= 0) {
      return this.extractFuzzerName(pathParts[fuzzerDirIndex]);
    }
    return "unknown";
  }
}

module.exports = { CrashDiscoveryService };
