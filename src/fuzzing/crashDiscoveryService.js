const vscode = require("vscode");
const fs = require("fs").promises;
const path = require("path");
const dockerOperations = require("../core/dockerOperations");

/**
 * CrashDiscoveryService - Discovers and parses fuzzing crash files
 *
 * This service uses the `codeforge find-crashes` command to discover crash files
 * generated by fuzzing operations and returns structured crash data.
 *
 * The find-crashes command returns data in the format:
 * fuzzername:path_relative_to_project_directory
 *
 * Directory structure expected:
 * .codeforge/fuzzing/{FUZZER}-output/crash-{HASH}
 */
class CrashDiscoveryService {
  constructor(resourceManager = null) {
    this.fs = fs;
    this.path = path;
    this.resourceManager = resourceManager;
  }

  /**
   * Executes the codeforge find-crashes command to discover crash files
   * @param {string} workspacePath - Path to the workspace root
   * @param {string} imageName - Docker image name for script execution
   * @returns {Promise<Array>} Array of {fuzzerName, crashPath} objects
   */
  async executeFindCrashesScript(workspacePath, imageName) {
    return new Promise((resolve, reject) => {
      const options = {
        removeAfterRun: true,
        mountWorkspace: true,
        dockerCommand: "docker",
        containerType: "crash_discovery",
      };

      // Execute the find-crashes script
      const findCommand = "codeforge find-crashes";

      const findProcess = dockerOperations.runDockerCommandWithOutput(
        workspacePath,
        imageName,
        findCommand,
        "/bin/bash",
        { ...options, resourceManager: this.resourceManager },
      );

      let stdout = "";
      let stderr = "";

      findProcess.stdout.on("data", (data) => {
        stdout += data.toString();
      });

      findProcess.stderr.on("data", (data) => {
        stderr += data.toString();
      });

      findProcess.on("close", (code) => {
        if (code !== 0) {
          // Handle case where no crashes are found (not an error)
          if (
            stderr.includes("No crashes found") ||
            stdout.trim().length === 0
          ) {
            console.log("No crashes found in project");
            resolve([]);
            return;
          }

          reject(
            new Error(
              `Find crashes script failed with exit code ${code}: ${stderr}`,
            ),
          );
          return;
        }

        try {
          // Parse script output: "fuzzer_name/crash_hash" format
          const crashList = this.parseFindCrashesScriptOutput(stdout);
          resolve(crashList);
        } catch (parseError) {
          reject(
            new Error(
              `Failed to parse find crashes script output: ${parseError.message}`,
            ),
          );
        }
      });

      findProcess.on("error", (error) => {
        reject(
          new Error(`Failed to execute find crashes script: ${error.message}`),
        );
      });
    });
  }

  /**
   * Parses the output from codeforge find-crashes command
   * @param {string} stdout - Script output in format: fuzzername:path_relative_to_project_directory
   * @returns {Array} Array of {fuzzerName, crashPath} objects
   */
  parseFindCrashesScriptOutput(stdout) {
    const crashList = [];
    const lines = stdout
      .trim()
      .split("\n")
      .filter((line) => line.trim());

    for (const line of lines) {
      const trimmedLine = line.trim();
      if (trimmedLine && trimmedLine.includes(":")) {
        const colonIndex = trimmedLine.indexOf(":");
        if (colonIndex > 0) {
          const fuzzerName = trimmedLine.substring(0, colonIndex).trim();
          const crashPath = trimmedLine.substring(colonIndex + 1).trim();
          if (fuzzerName && crashPath) {
            crashList.push({
              fuzzerName,
              crashPath,
            });
          }
        }
      }
    }

    return crashList;
  }

  /**
   * Scans for crashes in the workspace fuzzing directories
   * @param {string} workspacePath - Path to the workspace root
   * @param {string} imageName - Optional Docker image name for script execution
   * @returns {Promise<FuzzerCrashData[]>} Array of fuzzer crash data
   */
  async discoverCrashes(workspacePath, imageName = null) {
    const fuzzingDir = this.path.join(workspacePath, ".codeforge", "fuzzing");

    try {
      await this.fs.access(fuzzingDir);
    } catch (error) {
      // No fuzzing directory exists - this is normal for new projects
      return [];
    }

    try {
      // Generate image name if not provided
      if (!imageName) {
        imageName = dockerOperations.generateContainerName(workspacePath);
      }

      // Execute codeforge find-crashes command to get crash files
      const crashList = await this.executeFindCrashesScript(
        workspacePath,
        imageName,
      );

      // Group crashes by fuzzer
      const crashDataMap = new Map();

      for (const crashItem of crashList) {
        const { fuzzerName, crashPath } = crashItem;

        // Build full path to crash file
        const fullCrashPath = this.path.join(workspacePath, crashPath);

        // Get file stats for size and creation date
        let stats;
        try {
          stats = await this.fs.stat(fullCrashPath);
        } catch (error) {
          console.warn(
            `Failed to get stats for crash file ${fullCrashPath}: ${error.message}`,
          );
          continue;
        }

        // Extract crash hash from filename (format: crash-{HASH})
        const fileName = this.path.basename(crashPath);
        const crashHash = fileName.replace(/^crash-/, "");

        // Build output directory path
        const outputDir = this.path.join(fuzzingDir, `${fuzzerName}-output`);

        // Create crash info from command output and file stats
        const crashInfo = {
          id: crashHash.substring(0, 9), // First 9 characters
          fullHash: crashHash,
          fileName: fileName,
          filePath: fullCrashPath,
          fileSize: stats.size,
          createdAt: stats.birthtime.toISOString(),
          fuzzerName,
        };

        // Add to fuzzer's crash list
        if (!crashDataMap.has(fuzzerName)) {
          crashDataMap.set(fuzzerName, {
            fuzzerName,
            crashes: [],
            outputDir,
            lastScan: new Date().toISOString(),
          });
        }

        crashDataMap.get(fuzzerName).crashes.push(crashInfo);
      }

      // Convert map to array and sort crashes within each fuzzer by creation date (newest first)
      const crashData = Array.from(crashDataMap.values()).map((fuzzerData) => ({
        ...fuzzerData,
        crashes: fuzzerData.crashes.sort((a, b) =>
          b.createdAt.localeCompare(a.createdAt),
        ),
      }));

      return crashData;
    } catch (error) {
      // Handle permission errors and other file system issues
      if (this.isPermissionError(error)) {
        throw new Error(
          `Permission denied while scanning for crashes: ${error.message}`,
        );
      }
      throw new Error(`Failed to scan for crashes: ${error.message}`);
    }
  }

  /**
   * Checks if an error is a permission-related error on any platform
   * @param {Error} error - The error to check
   * @returns {boolean} True if it's a permission error
   */
  isPermissionError(error) {
    // Unix permission error codes
    if (error.code === "EACCES" || error.code === "EPERM") {
      return true;
    }

    // Windows permission error codes
    if (error.code === "EBUSY" || error.code === "ENOTEMPTY") {
      return true;
    }

    // Check error message for Windows permission patterns
    const message = error.message.toLowerCase();
    if (
      message.includes("permission denied") ||
      message.includes("access denied") ||
      message.includes("operation not permitted")
    ) {
      return true;
    }

    return false;
  }
}

module.exports = { CrashDiscoveryService };
